# demo frontend (HTTP)
# URL style:
#   http://host:${FRONTEND_PORT}/demo/storer/
# Auto-redirects to include ebus/rest query params:
#   /demo/storer/?ebus=ws://host:12004&rest=http://host:12001

include /etc/nginx/conf.d/apps.map.conf;

server {
  listen 80;
  server_name _;

  # /demo/storer -> /demo/storer/
  location ~ ^/demo/(?<app>[^/]+)$ {
    # $http_host contains host:port as sent by client
    return 302 http://$http_host/demo/$app/;
  }

  # Root of each app: if query missing, redirect to include endpoints.
  # Note: we still serve the static GUI (index.html) on /demo/<app>/.
  location ~ ^/demo/(?<app>[^/]+)/$ {
    if ($arg_ebus = "") {
      # Use $http_host to preserve :PORT in redirects (e.g., :8088)
      return 302 http://$http_host/demo/$app/?ebus=ws://$host:$mq_ws_port&rest=http://$host:$rest_port;
    }
    if ($arg_rest = "") {
      return 302 http://$http_host/demo/$app/?ebus=ws://$host:$mq_ws_port&rest=http://$host:$rest_port;
    }

    root /usr/share/nginx/html;
    try_files /demo/$app/index.html =404;
  }

  # /media -> /media/
  location = /media {
    return 302 /media/;
  }

  # Some GUIs are hard-coded to fetch /media/... from the same origin.
  # We proxy /media/ to the corresponding instance REST port based on Referer:
  #   Referer: http://host:8088/demo/<app>/...
  # Then proxy to:
  #   http://host:<rest_port>/media/...
  # Uses $media_proxy_port map from apps.map.conf (no meshnet needed)
  location ^~ /media/ {
    # If we can't infer app from Referer, return 404
    if ($media_proxy_port = "") {
      return 404;
    }

    # Use Docker internal DNS to resolve hostnames with variables
    resolver 127.0.0.11 valid=10s ipv6=off;

    proxy_http_version 1.1;
    proxy_set_header Host $host;

    # Proxy to host REST port (works without meshnet)
    # 172.17.0.1 is the docker bridge gateway (host)
    proxy_pass http://172.17.0.1:$media_proxy_port$request_uri;
  }

  # Static assets
  location /demo/ {
    root /usr/share/nginx/html;
    try_files $uri $uri/ =404;
  }
}
